# AVL 树 (Adelson-Velsky-Landis Tree)

## 什么是 AVL 树？

AVL 树是**第一种自平衡二叉搜索树**，由苏联数学家 Adelson-Velsky 和 Landis 于 1962 年发明。它通过维护每个节点的平衡因子来确保树始终保持平衡，保证查找、插入、删除操作的时间复杂度都是 **O(log n)**。

## AVL 树的核心性质

### 1. 平衡因子 (Balance Factor)

```
平衡因子 = 左子树高度 - 右子树高度
```

对于 AVL 树中的任意节点：
- 平衡因子只能是：**-1、0、1**
- 如果平衡因子超出这个范围，树就失衡了

### 2. 节点高度定义

```
节点高度 = 1 + max(左子树高度, 右子树高度)
空节点高度 = 0
```

### 3. AVL 树特点

| 特点 | 说明 |
|------|------|
| 严格平衡 | 任何节点的左右子树高度差不超过 1 |
| 查找高效 | 由于严格平衡，查找性能优于红黑树 |
| 旋转较多 | 插入删除时可能需要多次旋转 |
| 应用场景 | 读多写少的场景（如数据库索引） |

## 四种旋转操作

当插入或删除节点导致失衡时，需要通过旋转恢复平衡。

### LL 型 - 右单旋

**触发条件**：在左子树的左子树上插入节点导致失衡

```
    30 (BF=2)             20 (BF=0)
   /        右旋         /  \
  20        =>          10   30
 /
10
```

### RR 型 - 左单旋

**触发条件**：在右子树的右子树上插入节点导致失衡

```
  10 (BF=-2)               20 (BF=0)
    \         左旋        /  \
    20        =>         10   30
      \
       30
```

### LR 型 - 先左后右

**触发条件**：在左子树的右子树上插入节点导致失衡

```
    30 (BF=2)             30               20 (BF=0)
   /         左旋10      /    右旋30      /  \
  20        =>          20      =>      10   30
    \                   /
    10                 10
```

### RL 型 - 先右后左

**触发条件**：在右子树的左子树上插入节点导致失衡

```
  10 (BF=-2)           10                  20 (BF=0)
    \        右旋30      \      左旋10    /  \
    30       =>          20      =>     10   30
    /                      \
   20                      30
```

## AVL 树 vs 红黑树

| 特性 | AVL 树 | 红黑树 |
|------|--------|--------|
| 平衡程度 | 严格平衡 | 近似平衡 |
| 查找性能 | 更快 | 稍慢 |
| 插入删除 | 旋转较多 | 旋转较少 |
| 应用场景 | 读多写少 | 通用（如 `std::map`） |
| 实现复杂度 | 稍简单 | 稍复杂 |

## 操作时间复杂度

| 操作 | 平均 | 最坏 |
|------|------|------|
| 查找 | O(log n) | O(log n) |
| 插入 | O(log n) | O(log n) |
| 删除 | O(log n) | O(log n) |

## 测试用例说明

本教程提供了 10 个渐进式测试：

| 测试 | 内容 | 学习目标 |
|------|------|---------|
| test01 | 基础插入 | 理解 AVL 树的基本操作 |
| test02 | RR 旋转 | 掌握左单旋操作 |
| test03 | LL 旋转 | 掌握右单旋操作 |
| test04 | LR 旋转 | 掌握先左后右双旋 |
| test05 | RL 旋转 | 掌握先右后左双旋 |
| test06 | 综合插入 | 综合运用各种旋转 |
| test07 | 删除操作 | 理解删除后的平衡修复 |
| test08 | 搜索操作 | 验证 BST 查找性质 |
| test09 | 边界情况 | 处理空树、单节点等 |
| test10 | 大规模数据 | 验证树的平衡性 |

## 运行

```bash
# 使用 ok-cpp 运行
ok-cpp run cpp_notes/algorithm/02_tree/03_AVL_tree

# 或手动编译运行
cd cpp_notes/algorithm/02_tree/03_AVL_tree
cmake -B build
cmake --build build
./build/03_AVL_tree
```

## 扩展阅读

- [算法导论 第 13 章 - 红黑树](https://en.wikipedia.org/wiki/AVL_tree)
- [AVL 树可视化](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)
- `test_class/my_AVLTree.h` - AVL 树完整实现代码
