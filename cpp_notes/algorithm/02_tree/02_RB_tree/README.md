# 红黑树 (Red-Black Tree)

## 什么是红黑树？

红黑树是一种**自平衡二叉搜索树**，通过为节点着色（红/黑）和旋转操作来保持平衡，确保在最坏情况下基本操作（插入、删除、查找）的时间复杂度为 **O(log n)**。

## 红黑树的 5 条性质

1. 每个节点不是红色就是黑色
2. 根节点是黑色
3. 所有叶子节点（NIL 哨兵）是黑色
4. **红色节点的两个子节点必须是黑色**（不能有连续的红色节点）
5. 从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点（**黑高相同**）

## 为什么需要红黑树？

| 数据结构 | 查找 | 插入 | 删除 | 特点 |
|---------|------|------|------|------|
| 数组 | O(n) | O(n) | O(n) | 简单 |
| 链表 | O(n) | O(1) | O(1) | 插入快 |
| 普通BST | O(log n) ~ O(n) | O(log n) ~ O(n) | O(log n) ~ O(n) | 可能退化 |
| AVL树 | O(log n) | O(log n) | O(log n) | 严格平衡，旋转多 |
| **红黑树** | **O(log n)** | **O(log n)** | **O(log n)** | **近似平衡，应用广泛** |

**红黑树 vs AVL 树：**
- AVL 树更严格平衡，查找更快
- 红黑树旋转次数更少，插入删除更快
- 实际应用中红黑树更常见（如 `std::map`、`std::set`、Java `TreeMap`）

## 插入修复的三种情况

插入的新节点默认为**红色**，然后检查是否违反性质 4（红父红子）：

### 情况 1：叔叔是红色

```
       B(黑)              R(红)
      /   \    变色      /   \
    R(红) R(红)  =>    B(黑) B(黑)
   /                    /
R(新)                 R(新)
```

**处理：** 父亲和叔叔变黑，祖父变红，继续向上检查

### 情况 2：叔叔是黑色，"一"字形（LL 或 RR）

**LL 型（右旋）：**
```
    R(黑)              B(黑)
   /                  /   \
R(红)      右旋   =>  R(红) R(黑)
  \                /
   R(新)        R(新)
```

**RR 型（左旋）：**
```
  R(黑)              B(黑)
    \                /   \
    R(红)   左旋  =>  R(黑) R(红)
    /                        \
  R(新)                      R(新)
```

**处理：** 父亲变黑，祖父变红，旋转

### 情况 3：叔叔是黑色，"之"字形（LR 或 RL）

**LR 型（先左旋父，再右旋祖父）：**
```
    R(黑)            R(黑)              B(黑)
   /                /                  /   \
R(红)   左旋父  =>  R(新)  右旋祖父 =>  R(新) R(红)
  \                    \                    /
   R(新)              R(红)              R(红)
```

**RL 型（先右旋父，再左旋祖父）：**
```
  R(黑)              R(黑)                B(黑)
    \                  \                  /   \
    R(红)   右旋父  =>    R(新)  左旋祖父 => R(红) R(新)
    /                    /                      \
  R(新)                R(红)                    R(红)
```

**处理：** 先转为"一"字形，再按情况 2 处理

## 删除修复

删除比插入更复杂，需要处理 4 种情况。核心思想是**借黑色节点**来保持黑高相同。

## 测试用例说明

本教程提供了 8 个渐进式测试：

| 测试 | 内容 | 学习目标 |
|------|------|---------|
| test01 | 基础插入 | 理解红黑树的基本操作 |
| test02 | 叔叔红色 | 掌握情况 1 的修复（变色） |
| test03 | 叔叔黑色（左） | 掌握 LL/LR 型旋转 |
| test04 | 叔叔黑色（右） | 掌握 RR/RL 型旋转 |
| test05 | 复杂插入 | 综合运用各种修复 |
| test06 | 删除操作 | 理解删除后的修复 |
| test07 | 边界情况 | 处理空树、单节点等 |
| test08 | 大规模数据 | 验证树的平衡性 |

## 运行

```bash
# 编译
cd cpp_notes/algorithm/02_tree/02_RB_tree
cmake -B build
cmake --build build

# 运行
./build/02_RB_tree
```

## 输出格式

- `R` 表示红色节点
- `B` 表示黑色节点
- 中序遍历验证了 BST 的有序性

## 扩展阅读

- [算法导论 第 13 章：红黑树](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)
- [红黑树可视化](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)
- `test_class/RBTree.h` - 红黑树完整实现代码
