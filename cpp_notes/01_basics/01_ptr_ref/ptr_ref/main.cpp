#include <iostream>

/* 指针和引用的区别
    指针：存放对象地址的变量，本身有地址，可以改变指向
    指针的本质是一个变量，但这个变量存储的不是普通的数据值，而是另一个变量的内存地址。
    1. 指针本身是一个独立的变量： 有自己的内存空间，用来存储一个地址值。这个地址值指向内存的某个位置，是另一个变量的起始地址。
    2. 指针可以间接访问或修改其指向的内存位置： 有一个变量的内存地址就可以通过这个地址找到并操作那个变量。这种通过地址进行的操作称为“间接访问”或“解引用”。

    引用：变量的别名，从一而终，不可变，必须初始化
    从最核心的层面来看，C++引用是一个别名。
    1. 引用不是一个独立的对象： 不创建新的内存空间来存储一个值或地址。只是现有对象的一个替代名称。就像一个人有两个名字，但是同一个人。
    2. 对引用的操作等同直接对它所引用的对象进行操作： 通过引用来读取或修改数据实际上是在直接操作它所绑定的那个原始对象。
       编译器在底层会用地址来实现引用，但对使用来说，引用就像是原始对象本身。
*/

void test01()
{
    int temp = 10;

    // 常量指针（底层cosnt）- 不能通过指针修改值
    const int *a = &temp;
    int const *b = &temp; // 等价于上式
    // *a = 0; // ❌ 错误：表达式必须是可以修改的左值

    std::cout << "*a=" << *a << ", *b=" << *b << "\n";

    // 指针常量（顶层const）- 不能改变指向
    int *const p = &temp;
    *p = 9; // 可以通过指针修改值
    // p = &temp2; // ❌ 错误：表达式必须是可以修改的左值

    std::cout << "*p=" << *p << "\n";

    // 引用示例
    int& ref = temp; // 引用必须初始化
    ref = 15; // 直接修改原变量
    // int& ref2; // ❌ 错误：引用必须初始化
    // int& ref3 = nullptr; // ❌ 错误：不存在空引用

    std::cout << "ref=" << ref << "\n";

    // 常量引用
    const int& cref = temp;
    // cref = 20; // ❌ 错误：不能通过常量引用修改值
    temp = 20; // 正确：直接修改原变量
}

void test02()
{
    int arr[5] = {1, 2, 3, 4, 5};

    // 数组指针：指向数组的指针
    int (*arrPtr)[5] = &arr;
    for (int i = 0; i < 5;++i) {
        std::cout << (*arrPtr)[i] << " ";
    }
    std::cout << "\n";

    // 指针数组：储存指针的数组
    int *ptrArr[5];
    for (int i = 0; i < 5; ++i) {
        ptrArr[i] = &arr[i];
    }

    for (int i = 0; i < 5; ++i) {
        std::cout << *ptrArr[i] << " ";
    }
    std::cout << "\n";
}

int main() {
    test02();
    return 0;
}